// // C언어 시작
// // 5월 22일 목요일

//////////////////////////////////////////////////////
// // 복습시작 : 7월 28일 월요일
// // 1일차 : 7월 29일 화요일
// // 3일차 :
// // 7일차 : 
/////////////////////////////////////////////////////

// // *************** 5월 22일 6강 시작 *****************

// // Exapmle 1)
// #include <stdio.h>  // IO관련 헤더파일 불러옴. 전처리기
// #define APPLE 10    // 앞으로 APPLE이라는 이름을 10으로 사용하겠다.
// #define NAME "사과"  // 문자열을 정의할때는 ""로 감싸야함

// // 한줄 주석 (설명)
// /* 여러줄 주석
// * 여기부터 주석 시작
// * 여기도 주석
// * 여기까지 주석
// */


// // *************** 5월 22일 9강 시작 ******************

// // C언어 시작인 메인함수 시작
// int main()
// {
//     char ch;    // 문자형 변수 선언
//     int num;    // 정수형 변수 선언
//     double x;   // 실수형 변수 선언

//     int a = 20;
//     int b = 0xff;

//     // 터미널에 hello world를 프린트
//     printf("hello world\n\n\n");
//     printf("%s, %d, %c, %d%%, %x, %d \n\n\n", NAME, APPLE, 'a', a, b, b);

//     // 문자열은 "" 사용 VS char형은 '' 사용
//     // %s : 문자열, %d : 정수형, %c : 문자형, %x : 16진수, %% : %
//     // %f : 실수형, %o : 8진수
//     // %p : 포인터형, %u : unsigned int
//     // \n 줄바꿈
//     // \r 커서를 맨 앞으로
//     // \t 탭 (4칸 띄우기)
// }


// // Example 2)
// #include <stdio.h>

// // sizeof() 연산자 - 괄호안에 있는것을 바이크 크기로 반환 (비트가 아님!)
// int main()
// {
//     char ch;
//     int num;
//     double x;
//      // 여기서는 값을 사용하는게 아니라 측정만 하기 때문에 
//      // 초기화 하지 않아도 쓰레기값 문제가 발생하지 않는다

//     printf("char 형의 바이트 크기 : % d \n", sizeof(char));
//     printf("short 형의 크기 : % d \n", sizeof(short));
//     printf("long 형의 바이트 크기 : % d \n", sizeof(long));
//     printf("float 형의 바이트 크기 : % d \n", sizeof(float));

//     printf("ch 형의 바이트 크기 : % d \n", sizeof(ch));
//     printf("num 형의 바이트 크기 : %d \n", sizeof(num));
//     printf("x 형의 바이트 크기 : % d \n", sizeof(x));
// }


////////////////////////////////////
// // 복습시작 : 7월 29일 화요일
// // 1일차 : 7월 30일 수요일
// // 3일차 :
// // 7일차 :
////////////////////////////////////


// C언어에서 변수의 선언과 사용
// int num
// 영문자, 숫자, 특수문자(_) : 변수명 선언시
// 첫글자는 반드시 영문자, 특수문자만 가능
// c언어는 대/소문자를 구별
// 변수명에 키워드 (예약어) 사용 불가

// 카멜표기법 => int manAge : 첫단어는 소문자, 결합되는 단어는 대문자로 시작
// 스네이크표기법 => int man_Age : 단어사이는 언더스코어로 연결
// 파스칼 표기법 => int ManAge : 모든 단어를 대문자로 시작
// 헝가리안표기법 => int iManName : 변수명앞에 데이터형의 약자를 넣어줌

// 변수의 초기화
// 변수를 선언하고 초기화하지 않으면 지역변수는 쓰레기값임

// Example 3)

// #include <stdio.h>

// int g;  // 전역변수(global varialbe) : 함수 밖에서 선언된 변수

// int main()
// {
//     int price; // 초기화 하지 않으면 쓰레기값 출력 
//     // int price = 6;  // 지역변수(Local variable) : 함수안에서 선언된 변수
//     static int num; // 정적변수(Static varialbe) : 함수안에서 선언된 변수
//                     //                          초기화가 안되면 0으로 초기화됨
//     printf("%d \n", price);
//     printf("%d \n", g);
//     printf("%d \n", num);
// }

// // ********* 5월 22일 10강 시작 ************

// Example 4)

// #include <stdio.h>

// int main()
// {
//     int amount = 0;
//     int price = 0;
//     int totalPrice = 0; // 3개 모두 지역변수기 때문에 0으로 초기화

//     printf("amount = %d, price = %d \n", amount, price);

//     printf("수량을 넣으시오 : ");
//     scanf("%d", &amount);   // scanf는 출력이 아닌 입력을 받아들임. stdio의 대표적인 예

//     // scanf 함수
//     // "%d": 10진수 정수형 데이터를 입력받겠다는 형식 지정자임
//     // "&amount": 입력받은 값을 저장할 변수의 '주소'를 나타냄
//     //            변수 이름 앞에 '&'를 붙여야 변수가 저장된 메모리 위치를 알려줄 수 있음
//     //            scanf는 이 주소에 사용자가 입력한 값을 직접 저장함
//     //           (이 부분은 '포인터' 개념과 밀접하게 관련됩니다. 나중에 더 자세히 다룰 것입니다.)


//     price = 100;

//     totalPrice = amount * price;
//     printf("합계 : %d \n\n\n", totalPrice);
// }


// Example 5)

// 산술 연산자
// +, -, *, /, %(나머지), ++, --(증감연산자 : 정수값이 오르거나 빼짐)
// ex) 3 ++ -> 4, 3 -- -> 2

// #include <stdio.h>

// int main()
// {
//     int a = 39;
//     int b = 17;
//     int result; // 연산 결과를 저장할 정수형 변수
//                 // Q) 이거 왜 지역변수인데 초기화 안해? 라는 의문 가질것
//                 // A) 이 변수는 선언 직후 바로 값을 할당받기 때문에 쓰레기 값을 받지 않음
//                 // 따라서 명시적인 초기화가 필수는 아니지만 명확성을 위해 0으로 초기화하는 습관이 좋음

//     result = a + b;
//     printf("a + b = %d \n", result);

//     result = a - b;
//     printf("a - b = %d \n", result);

//     result = a * b;
//     printf("a * b = %d \n", result);

//     result = a / b;
//     printf("a / b = %d \n", result);    // 39 / 17 = 2.234...실수는 인정안되서 2까지 출력

//     result = a % b;
//     printf("a %% b = %d \n", result);   // % 출력할 때는 %% 처럼 2개 써줘야한다.
// }


// 대입연산자
// = : 우측에 있는 넘을 좌측으로 대입 (저장, 입력)
// +=, -=, *=, /=, %= : 대입연산자와 산술연산자를 결합한 연산자. 복합연산자.
/*
* ex
* int a = 3;
* int b = 4;
* int c = 0;
* c = a + b;
* a += b; 이 식을 자세하게 풀면 a = a + b; 이다
* 저장장치라서 가능한 논리이지 수학이랑 개념이 다르다.
* 그런데 여기서 a = a + b 이면 3 = 3 + 4 인데
* 3 + 4 를 연산한 값 7을 3 = 에 덮에 씌워서 7 = 3 + 4 를 만든다.
*/


// 관계연산자
// ==(같다), !=(같지않다), >(크다), <(작다), >=(크거나 같다), <= (작거나 같다)

// 논리연산자
// && 두 개의 값이 true 일때 ture           : AND
// || 두 개의 값 중 하나라도 true 일때 true   : OR
// !  true 이면 false, false 이면 true     : NOT


// // Example 6-1)

// #include <stdio.h>

// int main()
// {
//     int month;  // 변수선언
//     // int month = 0; // 초기화 안했지만 바로 이어서 scanf에서 쓰기 때문에 상관없음
//     printf("몇 월??? : \n");
//     scanf("%d", &month);

//     if(month >= 6 && month <= 8)    // AND 6, 7, 8
//     {
//         printf("성수기 요금 적용 \n");
//     }
//     // 이 조건을 만족하면 "성수기 요즘 적용" printf가 실행되고
//     // 만족하지 못하면 이 if문을 무시한다.

//     if (month < 6 || month > 8)     // OR 1, 2, 3, 4, 5, 9, 10, 11, 12
//     {
//         printf("일반 요금 적용 \n");
//     }
//     // 첫 번째 if문의 조건을 만족하지 못했을 때 두번째 if문을 실행한다.
//     // 첫 번째 조건을 만족했다고 해서 두번째 if문을 무시하는 것이 아니다.
//     // 두번째 문장의 if문의 조건을 만족하지 않았기 때문에 무시되는 것이다.
//     // 문장을 만들 때 두개의 if문이 다 실행되게 하면 안되고 선택지가 있도록 만들어야한다.
//     // 만약 두번째 if문의 조건을 if(month < 8 || month > 8)
//     // 로 수정하고 7을 입력하면 둘다 printf 된다.
    
// }


// // Example 6-2)

// #include <stdio.h>

// int main()
// {
//     int month;
//     printf("몇 월??? : \n");
//     scanf("%d", &month);

//     // if-else if-else 구조의 예시
//     if (month >= 6 && month <= 8) // 첫 번째 조건 (성수기)
//     {
//         printf("성수기 요금 적용 \n");
//     }
//     else if (month >= 1 && month <= 12) // 첫 번째 조건이 거짓일 경우에만 이 조건 검사 (유효한 월)
//     {
//         printf("일반 요금 적용 \n");
//     }
//     else // 위의 모든 조건이 거짓일 경우 (예: 0월, 13월 등 유효하지 않은 월)
//     {
//         printf("유효하지 않은 월입니다. \n");
//     }
//     // 1. 첫 번째 if 문 조건 분석: (month >= 6 && month <= 8)
//     // 이 조건이 참이 되는 경우는 month 변수의 값이 6, 7, 8 일때

//     // 2. else if (month >= 1 && month <= 12)가 month < 6 || month > 8과 동일한 의미가 되는 이유
//     // 이 부분이 if-else if-else 구조의 핵심 논리

//     // else if는 바로 앞의 if (또는 else if) 조건이 거짓일 때에만 그 조건을 검사함
//     // 첫 번째 if 조건: (month >= 6 && month <= 8)
//     // 이 조건이 참이면 "성수기 요금 적용"을 출력하고 나머지 else if와 else 블록은 아예 검사하지 않고 건너뜀
//     // 즉, month가 6, 7, 8일 경우에는 else if 부분이 실행될 기회조차 없음

//     // else if 조건: (month >= 1 && month <= 12)
//     // 이 else if 블록은 **오직 첫 번째 if 조건(month가 6,7,8이 아닐 때)**만 검사함
//     // 따라서 이 else if가 검사되는 시점에서는 month의 값은 이미 6,7,8이 아님이 보장된 상태

//     // 이 상태에서 (month >= 1 && month <= 12)라는 조건은 1,2,3,4,5월이거나 9,10,11,12월인 경우를 의미. 
//     // 왜냐하면 6,7,8월은 이미 첫 번째 if에서 처리되었고
//     // 1 ~ 12월 사이의 유효한 월 중에서 6,7,8월을 제외한 나머지 월이기 때문

//     // 결론적으로, else if (month >= 1 && month <= 12)는 
//     // 이 특정 if-else if-else 문맥 내에서 논리적으로 (month < 6 || month > 8)와 동일한 효과를 가진다.
//     // 이는 프로그래머가 코드의 논리적 흐름을 고려하여 조건을 생략하거나 단순화할 수 있음을 보여주는 좋은 예시입니다.

// }

// // ****************** 5월 22 12강 시작 ***************************

////////////////////////////////////////////
// // 복습시작 : 7월 30일 수요일
// // 1일 :
// // 3일 : 
// // 7일 : 
////////////////////////////////////////////

// 삼항연산자 (또는 조건연산자)
// expression1 ? expression2 : expression3
// 만약 exprresion1이 참이면 exp2가 수행, 참이 아니면(거짓이 아님!) exp3이 수행됨

// ex)
// a = 1, b = 0
// a || b ? 1 : 2
// C언어에서는 0을 거짓으로 표현, 1을 참으로 표현한다.
// || (or연산자) : 논리표에 의해 a || b (exp1)가 참이므로 1(exp2)이 실행
// or 연산자는 하나만 참이어도 참이 나온다.

// a && b ? 1 : 2
// && (and연산자) : 논리표에 의해 a && b (epx1)은 거짓이므로 2(exp3)가 실행됨
// and 연산자는 둘다 참이어야지만 참이다

// 삼항 연산자는 잘 안쓰게 된다. 
// 하지만 남이 쓴 코드를 긁어다가 쓰는 경우도 있으니까 볼줄은 알아야함.
// if문으로 대체 할 수 있지만 길어질 수도 있다.
/*
ex)
// 삼항 연산자
int max = (a > b) ? a : b;

// if-else 문으로 동일하게 구현
int max;
if (a > b) {
    max = a;
} else {
    max = b;
}
*/


// 특수연산자
// sizeof() // 소괄호안의 것을 바이트크기로 변환 (비트가 아님에 주의)
// &        // 변수가 저장된 메모리상의 주소값을 반환(주소연산자)
            // 해당 변수가 메모리에서 어느 위치에 저장되어 있는지를 
            // 나타내는 고유한 식별 번호를 얻는다는 의미
// *        // 변수의 포인터 (혼자쓰이느냐 같이 쓰이느냐에 따라 의미가 다름)

// 비트연산자(바이트는 a, b로 표현했고 비트는 0, 1만 들어갈 수 있다)
// &, |, ^(XOR - 두개가 다르면 1을 반환), ~(not), <<, >>
// 바이트 연산자와 차이점은 비트냐 바이트냐의 차이이다

// 2진수를 16진수로 한번에 바꾸는법
// 1110 1101 (msb lsb) 처럼 4개씩 끊어준다
// {(8 * 1) + (4 * 1) + (2 * 1) + (1 * 0)}
// + {(8 * 1) + (4 * 1) + (2 * 0) + (1 * 1)} = 14 + 13
// 이 결과를 16진수로 변환하면 E, D이다. 정답은 0xED
// 0x가 붙으면 hexa(16진수) 값을 나타낸다. 0x17이면 십칠이 아니라 일 칠 이다
// 반대로 0x38을 2진수로 바꿔보면?
// 3과 8을 역산으로 해보면 0011 1000 이 된다.


// // Example 7-1)
// #include <stdio.h>

// int main()
// {                               // int는 4byte
//     int n1 = 15;                // 0b00000000 00000000 00000000 00001111
//     int n2 = 20;                // 0b00000000 00000000 00000000 00010100

//     int result1 = n1 & n2;      // 0b00000000 00000000 00000000 00000100
//     int result2 = n1 | n2;      // 0b00000000 00000000 00000000 00011111
//     int result3 = n1 ^ n2;      // 0b00000000 00000000 00000000 00011011
//     int result4 = ~n1;          // 0b11111111 11111111 11111111 11110000

//     printf("n1 = %d \n", n1);
//     printf("n2 = %d \n", n2);
//     printf("result = %d \n", result1);
//     printf("result = %d \n", result2);
//     printf("result = %d \n", result3);
//     printf("result = %d \n", result4);
// }


// // Example 7-2)
// #include <stdio.h>

// int main()
// {
//     int n1 = 1;         // 0b00000000 00000000 00000000 00000001
//     int s1 = n1 << 1;   // 0b00000000 00000000 00000000 00000010
//     int s2 = n1 << 2;   // 0b00000000 00000000 00000000 00000100
//     int s3 = n1 << 3;   // 0b00000000 00000000 00000000 00001000
//     int s4 = n1 << 4;   // 0b00000000 00000000 00000000 00010000

//     printf("n1 = %d \n", n1);
//     printf("s1 = %d \n", s1);
//     printf("s2 = %d \n", s2);
//     printf("s3 = %d \n", s3);
//     printf("s4 = %d \n", s4);
// }

// // ************** 5월 22일 수요일 강의 끝 *************///////////

// // ***************5월 23일 목요일 강의 1-1시작 *************

// // Example 1-1)
// #include <stdio.h>

// int main()
// {
//     char a; // -128 ~ 127

//     a = -128;
//     printf("%d \n", a);

//     a = -129;
//     printf("%d \n", a);
//     // 언더플로우
// }


// // Example 1-2)
// #include <stdio.h>

// int main()
// {
//     unsigned char a;    // 0 ~ 255

//     a = 255;
//     printf("%d \n", a);

//     a = 256;
//     printf("%d \n", a);
//     // 오버플로우
// }


// // Example 1-3)
// #include <stdio.h>

// int main()
// {
//     unsigned char a;

//     a = 255;
//     printf("%d \n", a);

//     a += 1;
//     // a = a + 1 와 같은 식
//     printf("%d \n", a);
// }


// // Example 2-1)
// // 비트 마스크 - 특정 비트를 조작
// #include <stdio.h>

// int main()
// {
//     unsigned short data = 0x5678;   // 0101 0110 0111 1000
//                                     // 정수형이고 2byte (16bit)
//     unsigned short msk1 = 0xf000;   // 1111 0000 0000 0000
//     unsigned short msk2 = 0x0f00;   // 0000 1111 0000 0000
//     unsigned short msk3 = 0x00f0;   // 0000 0000 1111 0000
//     unsigned short msk4 = 0x000f;   // 0000 0000 0000 1111

//     printf(" 결과값 1 = %#.4x \n", data & msk1);    // 0x5000
//     printf(" 결과값 2 = %#.4x \n", data & msk2);    // 0x0600
//     printf(" 결과값 3 = %#.4x \n", data & msk3);    // 0x0070
//     printf(" 결과값 4 = %#.4x \n", data & msk4);    // 0x0008
    
//     // %x: 16진수 소문자로 출력
//     // %.4x: 최소 4자리로 출력하고 부족하면 앞에 0을 채움
//     // (ex : 8 -> 0008)
//     // %#x: 16진수 값 앞에 0x 접두사를 붙여 출력
//     // (ex : 8 -> 0x8)
//     // 따라서 data & msk의 16진수 결과를 
//     // 0x 접두사를 붙여 4자리로 출력하라는 의미 (0x0008)

//     // & 는 내가 원하는 위치에 값을 뽑아옴
// }


// // Exampe 2-2)
// #include <stdio.h>

// int main()
// {
//     unsigned short data = 0x0000;   // 0000 0000 0000 0000
//                                     // 정수형이고 2byte (16bit)
//     unsigned short msk1 = 0xf000;   // 1111 0000 0000 0000
//     unsigned short msk2 = 0x0f00;   // 0000 1111 0000 0000
//     unsigned short msk3 = 0x00f0;   // 0000 0000 1111 0000
//     unsigned short msk4 = 0x000f;   // 0000 0000 0000 1111

//     printf(" 결과값 1 = %#.4x \n", data | msk1);    // 0xf000
//     printf(" 결과값 2 = %#.4x \n", data | msk2);    // 0x0f00
//     printf(" 결과값 3 = %#.4x \n", data | msk3);    // 0x00f0
//     printf(" 결과값 4 = %#.4x \n", data | msk4);    // 0x000f
    
//     // %x: 16진수 소문자로 출력
//     // %.4x: 최소 4자리로 출력하고 부족하면 앞에 0을 채움
//     // (ex : 8 -> 0008)
//     // %#x: 16진수 값 앞에 0x 접두사를 붙여 출력
//     // (ex : 8 -> 0x8)
//     // 따라서 data | msk의 16진수 결과를 
//     // 0x 접두사를 붙여 4자리로 출력하라는 의미 (0x0008)

//     // | 는 내가 원하는 위치에 값을 바꿀수 있다
// }

// // & 연산자는 특정비트를 0으로 만들고
// // | 연산자는 특정비트를 1로 만든다
// // ~ 연산자는 특정비트를 반전 시킨다
// /*
// 0b10101 -> 0b11101로 만들고 싶음
//   10101
// |     1 << 3 -> 01000

//   10101
// | 01000
// ---------
//   11101 -> 3번째 자리에 1을 추가함

// *** 삭제

//   11101 -> 3번째 자리의 1을 삭제하고 싶음 -> & 사용

//   1 << 3 -> 01000 -> ~(1 << 3) -> 10111

// */


// // Example 3-1)
// #include <stdio.h>

// int main()
// {
//     int a, b, c;    // int타입의 a, b, c 변수 선언
//     // int a;
//     // int b;
//     // int c;       // 위와 같은 것

//     double average; // 실수타입의 average 라는 변수 선언

//     printf("정수 3개를 입력하시오 : \n");
//     scanf("%d %d %d", &a, &b, &c);  // 정수 3개를 입력받음

//     average = (double)(a + b + c) / 3;  // 평균을 구함
//     printf("평균은 : %f \n", average);   // 평균을 출력함. f는 실수형 d는 정수형
//     // 형 변환
//     // (a + b + c)의 결과는 정수형. 만약 이 합계를 정수 3으로 바로 나누면
//     // 정수 나눗셈이 되어 소수점 이하가 버려지게 됨 (ex : 245 / 3 = 81)
//     // (double)(a + b + c)는 괄호 안의 정수 합계를 
//     // 일시적으로 double 타입으로 **명시적 형 변환**함
//     // 이렇게 되면 double 타입의 값과 int 타입의 3이 연산될 때
//     // 자동으로 3도 double로 **암시적 형 변환**되어 `double` 나눗셈이 수행됨
//     // 따라서 평균이 소수점까지 정확하게 계산된다(ex : 245.0 / 3.0 = 81.666...)
// }


// // Example 3-2)
// // 명시적 형 변환 (Explicit Type Casting)
// // 프로그래머가 직접 코드를 작성해서 특정 변수나 식의 데이터 타입을 다른 타입으로 강제로 바꿔주는 것
// // 마치 요리할 때 "이 재료를 꼭 이 형태로 잘라줘!"라고 명확하게 지시하는 것과 같다

// // How use?
// // 값을 변환하고 싶은 데이터 타입을 괄호 () 안에 넣고 변환할 변수나 식 앞에 붙여준다.
// // ex : (변환의 목표가 되는 자료형) 변수_또는_식
// #include <stdio.h>

// int main() 
// {
//     int sum = 245;
//     int count = 3;

//     // 명시적 형 변환 없으면 정수 나눗셈 (소수점 이하 버림)
//     double avg1 = sum / count;
//     printf("정수 나눗셈 평균: %.2f\n", avg1); // 출력: 81.00

//     // 명시적 형 변환 (double)을 사용하여 정확한 실수 나눗셈 유도
//     double avg2 = (double)sum / count; // sum을 double로 변환해서 연산
//     printf("명시적 형 변환 평균: %.2f\n", avg2); // 출력: 81.67

//     // 정수를 실수로 변환
//     int int_val = 10;
//     float float_val = (float)int_val;
//     printf("int를 float로: %.1f\n", float_val); // 출력: 10.0

//     // 실수를 정수로 변환 (소수점 이하 버림)
//     double double_val = 123.789;
//     int casted_int = (int)double_val;
//     printf("double을 int로: %d\n", casted_int); // 출력: 123
//                                              // 이 경우 데이터 손실(정밀도 손실)이 발생
// }


// // Example 3-3)
// // 암시적 형 변환 (Implicit Type Conversion)
// // 프로그래머가 별도로 지시하지 않아도 컴파일러가 자동으로 수행하는 형 변환
// // 마치 요리사가 알아서 "이 재료는 이렇게 써야 더 맛있지!"라며 재료 형태를 바꾸는 것과 비슷
// //  주로 데이터 손실을 최소화하는 방향으로 이루진다

// // when?
// // 서로 다른 자료형 간의 연산 : 
// // int와 double처럼 다른 타입의 변수끼리 연산할 때 
// // 더 넓은 범위를 표현할 수 있는 쪽으로 작은 타입이 자동으로 변환
// // 할당(대입) 연산: 더 작은 타입의 변수에 더 큰 타입의 값을 할당할 때 
// //               (이 경우 데이터 손실이 일어날 수 있으니 주의)
// // 함수 호출 시 인자 전달: 함수의 매개변수 타입과 전달하는 인자 타입이 다를 때
// #include <stdio.h>

// int main() 
// {
//     int i = 10;
//     double d = 3.5;

//     // int와 double의 덧셈 연산:
//     // i (int)가 d (double)에 맞춰 double로 자동 변환된 후 덧셈이 이루어진다
//     double result1 = i + d; // 10 (int) -> 10.0 (double)
//     printf("int + double 결과 (double에 저장): %.1f\n", result1); // 출력: 13.5

//     // int와 double의 덧셈 연산 후 int 변수에 저장:
//     // i (int)가 double로 변환되어 덧셈 후, 다시 int로 변환되어 result2에 저장
//     // 이 과정에서 소수점 이하(.5)가 버려지면서 데이터 손실이 발생
//     int result2 = i + d;
//     printf("int + double 결과 (int에 저장): %d\n", result2); // 출력: 13 (데이터 손실 발생!)

//     // float와 double의 곱셈 연산:
//     float f = 2.0f;
//     double result3 = f * d; // f (float)가 d (double)에 맞춰 double로 자동 변환된 후 곱셈
//     printf("float * double 결과: %.1f\n", result3); // 출력: 7.0

// }

// // 암시적 형 변환의 규칙 (일반적인 승격 순서)

// // bool -> char -> short int -> int -> long int -> long long int
// // -> float -> double -> long double


// // ************ 5월 23일 금요일 강의 2 시작 ***************


// // Example 4-1)
// #include <stdio.h>

// int main()
// {
//     int num = 0;

//     printf("숫자를 입력하세요. \n");
//     scanf("%d", &num);          // 정수를 받아서 num이라는 변수에 저장

//     if (num < 5)
//     {
//         printf("입력한 숫자는 5보다 작다.\n");
//     }
//     if (num == 5)
//     {
//         printf("입력한 숫자는 5와 같다.\n");
//     }
//     if (num > 5)
//     {
//         printf("입력한 숫자는 5보다 크다.\n");
//     }
    
// }
// // if문의 특징 : if문의 조건이 참이면 실행.
// // 각각의 if문은 조건을 독립적으로 검사하여 실행함
// // 하나만 참이어야하고 나머지는 참인지 따져보지 않아도 되는 
// // if - else if - else 문과는 차이가있다.(else if와 else 블록은 검사조차 안함)

// Example 4-2)
#include <stdio.h>

int main()
{
    int num = 0;

    printf("숫자를 입력하세요. \n");
    scanf("%d", &num);

    if (num < 5)
    {
        printf("입력한 숫자는 5보다 작다.\n");
    }
    else
    {
        if (num == 5)
        {
            printf("입력한 숫자는 5와 같다./n");
        }
        else
        {
            printf("입력한 숫자는 5보다 크다.\n");
        }
    }
    
}



// Example 4-3)
#include <stdio.h>

int main()
{
    int num = 0;

    printf("숫자를 입력하세요. \n");
    scanf("%d", &num);

    if (num < 5)
    {
        printf("입력한 숫자는 5보다 작다.\n");
    }
    else if(num == 5)
    {
        printf("입력한 숫자는 5와 같다.\n");
    }
    else
    {
        printf("입력한 숫자는 5보다 크다.\n");
    }
    
}

// 5월 23일 2강 27분 35초