// // C언어 시작
// // 5월 22일 목요일

//////////////////////////////////////////////////////
// // 복습시작 : 7월 28일 월요일
// // 1일차 : 7월 29일 화요일
// // 3일차 :
// // 7일차 : 
/////////////////////////////////////////////////////

// // *************** 5월 22일 6강 시작 *****************

// // Exapmle 1)
// #include <stdio.h>  // IO관련 헤더파일 불러옴. 전처리기
// #define APPLE 10    // 앞으로 APPLE이라는 이름을 10으로 사용하겠다.
// #define NAME "사과"  // 문자열을 정의할때는 ""로 감싸야함

// // 한줄 주석 (설명)
// /* 여러줄 주석
// * 여기부터 주석 시작
// * 여기도 주석
// * 여기까지 주석
// */


// // *************** 5월 22일 9강 시작 ******************

// // C언어 시작인 메인함수 시작
// int main()
// {
//     char ch;    // 문자형 변수 선언
//     int num;    // 정수형 변수 선언
//     double x;   // 실수형 변수 선언

//     int a = 20;
//     int b = 0xff;

//     // 터미널에 hello world를 프린트
//     printf("hello world\n\n\n");
//     printf("%s, %d, %c, %d%%, %x, %d \n\n\n", NAME, APPLE, 'a', a, b, b);

//     // 문자열은 "" 사용 VS char형은 '' 사용
//     // %s : 문자열, %d : 정수형, %c : 문자형, %x : 16진수, %% : %
//     // %f : 실수형, %o : 8진수
//     // %p : 포인터형, %u : unsigned int
//     // \n 줄바꿈
//     // \r 커서를 맨 앞으로
//     // \t 탭 (4칸 띄우기)
// }


// // Example 2)
// #include <stdio.h>

// // sizeof() 연산자 - 괄호안에 있는것을 바이크 크기로 반환 (비트가 아님!)
// int main()
// {
//     char ch;
//     int num;
//     double x;
//      // 여기서는 값을 사용하는게 아니라 측정만 하기 때문에 
//      // 초기화 하지 않아도 쓰레기값 문제가 발생하지 않는다

//     printf("char 형의 바이트 크기 : % d \n", sizeof(char));
//     printf("short 형의 크기 : % d \n", sizeof(short));
//     printf("long 형의 바이트 크기 : % d \n", sizeof(long));
//     printf("float 형의 바이트 크기 : % d \n", sizeof(float));

//     printf("ch 형의 바이트 크기 : % d \n", sizeof(ch));
//     printf("num 형의 바이트 크기 : %d \n", sizeof(num));
//     printf("x 형의 바이트 크기 : % d \n", sizeof(x));
// }


////////////////////////////////////
// // 복습시작 : 7월 29일 화요일
// // 1일차 : 7월 30일 수요일
// // 3일차 :
// // 7일차 :
////////////////////////////////////


// C언어에서 변수의 선언과 사용
// int num
// 영문자, 숫자, 특수문자(_) : 변수명 선언시
// 첫글자는 반드시 영문자, 특수문자만 가능
// c언어는 대/소문자를 구별
// 변수명에 키워드 (예약어) 사용 불가

// 카멜표기법 => int manAge : 첫단어는 소문자, 결합되는 단어는 대문자로 시작
// 스네이크표기법 => int man_Age : 단어사이는 언더스코어로 연결
// 파스칼 표기법 => int ManAge : 모든 단어를 대문자로 시작
// 헝가리안표기법 => int iManName : 변수명앞에 데이터형의 약자를 넣어줌

// 변수의 초기화
// 변수를 선언하고 초기화하지 않으면 지역변수는 쓰레기값임

// Example 3)

// #include <stdio.h>

// int g;  // 전역변수(global varialbe) : 함수 밖에서 선언된 변수

// int main()
// {
//     int price; // 초기화 하지 않으면 쓰레기값 출력 
//     // int price = 6;  // 지역변수(Local variable) : 함수안에서 선언된 변수
//     static int num; // 정적변수(Static varialbe) : 함수안에서 선언된 변수
//                     //                          초기화가 안되면 0으로 초기화됨
//     printf("%d \n", price);
//     printf("%d \n", g);
//     printf("%d \n", num);
// }

// // ********* 5월 22일 10강 시작 ************

// Example 4)

// #include <stdio.h>

// int main()
// {
//     int amount = 0;
//     int price = 0;
//     int totalPrice = 0; // 3개 모두 지역변수기 때문에 0으로 초기화

//     printf("amount = %d, price = %d \n", amount, price);

//     printf("수량을 넣으시오 : ");
//     scanf("%d", &amount);   // scanf는 출력이 아닌 입력을 받아들임. stdio의 대표적인 예

//     // scanf 함수
//     // "%d": 10진수 정수형 데이터를 입력받겠다는 형식 지정자임
//     // "&amount": 입력받은 값을 저장할 변수의 '주소'를 나타냄
//     //            변수 이름 앞에 '&'를 붙여야 변수가 저장된 메모리 위치를 알려줄 수 있음
//     //            scanf는 이 주소에 사용자가 입력한 값을 직접 저장함
//     //           (이 부분은 '포인터' 개념과 밀접하게 관련됩니다. 나중에 더 자세히 다룰 것입니다.)


//     price = 100;

//     totalPrice = amount * price;
//     printf("합계 : %d \n\n\n", totalPrice);
// }


// Example 5)

// 산술 연산자
// +, -, *, /, %(나머지), ++, --(증감연산자 : 정수값이 오르거나 빼짐)
// ex) 3 ++ -> 4, 3 -- -> 2

// #include <stdio.h>

// int main()
// {
//     int a = 39;
//     int b = 17;
//     int result; // 연산 결과를 저장할 정수형 변수
//                 // Q) 이거 왜 지역변수인데 초기화 안해? 라는 의문 가질것
//                 // A) 이 변수는 선언 직후 바로 값을 할당받기 때문에 쓰레기 값을 받지 않음
//                 // 따라서 명시적인 초기화가 필수는 아니지만 명확성을 위해 0으로 초기화하는 습관이 좋음

//     result = a + b;
//     printf("a + b = %d \n", result);

//     result = a - b;
//     printf("a - b = %d \n", result);

//     result = a * b;
//     printf("a * b = %d \n", result);

//     result = a / b;
//     printf("a / b = %d \n", result);    // 39 / 17 = 2.234...실수는 인정안되서 2까지 출력

//     result = a % b;
//     printf("a %% b = %d \n", result);   // % 출력할 때는 %% 처럼 2개 써줘야한다.
// }


// 대입연산자
// = : 우측에 있는 넘을 좌측으로 대입 (저장, 입력)
// +=, -=, *=, /=, %= : 대입연산자와 산술연산자를 결합한 연산자. 복합연산자.
/*
* ex
* int a = 3;
* int b = 4;
* int c = 0;
* c = a + b;
* a += b; 이 식을 자세하게 풀면 a = a + b; 이다
* 저장장치라서 가능한 논리이지 수학이랑 개념이 다르다.
* 그런데 여기서 a = a + b 이면 3 = 3 + 4 인데
* 3 + 4 를 연산한 값 7을 3 = 에 덮에 씌워서 7 = 3 + 4 를 만든다.
*/


// 관계연산자
// ==(같다), !=(같지않다), >(크다), <(작다), >=(크거나 같다), <= (작거나 같다)

// 논리연산자
// && 두 개의 값이 true 일때 ture           : AND
// || 두 개의 값 중 하나라도 true 일때 true   : OR
// !  true 이면 false, false 이면 true     : NOT


// // Example 6-1)

// #include <stdio.h>

// int main()
// {
//     int month;  // 변수선언
//     // int month = 0; // 초기화 안했지만 바로 이어서 scanf에서 쓰기 때문에 상관없음
//     printf("몇 월??? : \n");
//     scanf("%d", &month);

//     if(month >= 6 && month <= 8)    // AND 6, 7, 8
//     {
//         printf("성수기 요금 적용 \n");
//     }
//     // 이 조건을 만족하면 "성수기 요즘 적용" printf가 실행되고
//     // 만족하지 못하면 이 if문을 무시한다.

//     if (month < 6 || month > 8)     // OR 1, 2, 3, 4, 5, 9, 10, 11, 12
//     {
//         printf("일반 요금 적용 \n");
//     }
//     // 첫 번째 if문의 조건을 만족하지 못했을 때 두번째 if문을 실행한다.
//     // 첫 번째 조건을 만족했다고 해서 두번째 if문을 무시하는 것이 아니다.
//     // 두번째 문장의 if문의 조건을 만족하지 않았기 때문에 무시되는 것이다.
//     // 문장을 만들 때 두개의 if문이 다 실행되게 하면 안되고 선택지가 있도록 만들어야한다.
//     // 만약 두번째 if문의 조건을 if(month < 8 || month > 8)
//     // 로 수정하고 7을 입력하면 둘다 printf 된다.
    
// }


// // Example 6-2)

// #include <stdio.h>

// int main()
// {
//     int month;
//     printf("몇 월??? : \n");
//     scanf("%d", &month);

//     // if-else if-else 구조의 예시
//     if (month >= 6 && month <= 8) // 첫 번째 조건 (성수기)
//     {
//         printf("성수기 요금 적용 \n");
//     }
//     else if (month >= 1 && month <= 12) // 첫 번째 조건이 거짓일 경우에만 이 조건 검사 (유효한 월)
//     {
//         printf("일반 요금 적용 \n");
//     }
//     else // 위의 모든 조건이 거짓일 경우 (예: 0월, 13월 등 유효하지 않은 월)
//     {
//         printf("유효하지 않은 월입니다. \n");
//     }
//     // 1. 첫 번째 if 문 조건 분석: (month >= 6 && month <= 8)
//     // 이 조건이 참이 되는 경우는 month 변수의 값이 6, 7, 8 일때

//     // 2. else if (month >= 1 && month <= 12)가 month < 6 || month > 8과 동일한 의미가 되는 이유
//     // 이 부분이 if-else if-else 구조의 핵심 논리

//     // else if는 바로 앞의 if (또는 else if) 조건이 거짓일 때에만 그 조건을 검사함
//     // 첫 번째 if 조건: (month >= 6 && month <= 8)
//     // 이 조건이 참이면 "성수기 요금 적용"을 출력하고 나머지 else if와 else 블록은 아예 검사하지 않고 건너뜀
//     // 즉, month가 6, 7, 8일 경우에는 else if 부분이 실행될 기회조차 없음

//     // else if 조건: (month >= 1 && month <= 12)
//     // 이 else if 블록은 **오직 첫 번째 if 조건(month가 6,7,8이 아닐 때)**만 검사함
//     // 따라서 이 else if가 검사되는 시점에서는 month의 값은 이미 6,7,8이 아님이 보장된 상태

//     // 이 상태에서 (month >= 1 && month <= 12)라는 조건은 1,2,3,4,5월이거나 9,10,11,12월인 경우를 의미. 
//     // 왜냐하면 6,7,8월은 이미 첫 번째 if에서 처리되었고
//     // 1 ~ 12월 사이의 유효한 월 중에서 6,7,8월을 제외한 나머지 월이기 때문

//     // 결론적으로, else if (month >= 1 && month <= 12)는 
//     // 이 특정 if-else if-else 문맥 내에서 논리적으로 (month < 6 || month > 8)와 동일한 효과를 가진다.
//     // 이는 프로그래머가 코드의 논리적 흐름을 고려하여 조건을 생략하거나 단순화할 수 있음을 보여주는 좋은 예시입니다.

// }

// // ****************** 5월 22 12강 시작 ***************************

////////////////////////////////////////////
// // 복습시작 : 7월 30일 수요일
// // 1일 :
// // 3일 : 
// // 7일 : 
////////////////////////////////////////////

// 삼항연산자 (또는 조건연산자)
// expression1 ? expression2 : expression3
// 만약 exprresion1이 참이면 exp2가 수행, 참이 아니면(거짓이 아님!) exp3이 수행됨

// ex)
// a = 1, b = 0
// a || b ? 1 : 2
// C언어에서는 0을 거짓으로 표현, 1을 참으로 표현한다.
// || (or연산자) : 논리표에 의해 a || b (exp1)가 참이므로 1(exp2)이 실행
// or 연산자는 하나만 참이어도 참이 나온다.

// a && b ? 1 : 2
// && (and연산자) : 논리표에 의해 a && b (epx1)은 거짓이므로 2(exp3)가 실행됨
// and 연산자는 둘다 참이어야지만 참이다

// 삼항 연산자는 잘 안쓰게 된다. 
// 하지만 남이 쓴 코드를 긁어다가 쓰는 경우도 있으니까 볼줄은 알아야함.
// if문으로 대체 할 수 있지만 길어질 수도 있다.
/*
ex)
// 삼항 연산자
int max = (a > b) ? a : b;

// if-else 문으로 동일하게 구현
int max;
if (a > b) {
    max = a;
} else {
    max = b;
}
*/


// 특수연산자
// sizeof() // 소괄호안의 것을 바이트크기로 변환 (비트가 아님에 주의)
// &        // 변수가 저장된 메모리상의 주소값을 반환(주소연산자)
            // 해당 변수가 메모리에서 어느 위치에 저장되어 있는지를 
            // 나타내는 고유한 식별 번호를 얻는다는 의미
// *        // 변수의 포인터 (혼자쓰이느냐 같이 쓰이느냐에 따라 의미가 다름)

// 비트연산자(바이트는 a, b로 표현했고 비트는 0, 1만 들어갈 수 있다)
// &, |, ^(XOR - 두개가 다르면 1을 반환), ~(not), <<, >>
// 바이트 연산자와 차이점은 비트냐 바이트냐의 차이이다

// 2진수를 16진수로 한번에 바꾸는법
// 1110 1101 (msb lsb) 처럼 4개씩 끊어준다
// {(8 * 1) + (4 * 1) + (2 * 1) + (1 * 0)}
// + {(8 * 1) + (4 * 1) + (2 * 0) + (1 * 1)} = 14 + 13
// 이 결과를 16진수로 변환하면 E, D이다. 정답은 0xED
// 0x가 붙으면 hexa(16진수) 값을 나타낸다. 0x17이면 십칠이 아니라 일 칠 이다
// 반대로 0x38을 2진수로 바꿔보면?
// 3과 8을 역산으로 해보면 0011 1000 이 된다.


// // Example 7-1)
// #include <stdio.h>

// int main()
// {                               // int는 4byte
//     int n1 = 15;                // 0b00000000 00000000 00000000 00001111
//     int n2 = 20;                // 0b00000000 00000000 00000000 00010100

//     int result1 = n1 & n2;      // 0b00000000 00000000 00000000 00000100
//     int result2 = n1 | n2;      // 0b00000000 00000000 00000000 00011111
//     int result3 = n1 ^ n2;      // 0b00000000 00000000 00000000 00011011
//     int result4 = ~n1;          // 0b11111111 11111111 11111111 11110000

//     printf("n1 = %d \n", n1);
//     printf("n2 = %d \n", n2);
//     printf("result = %d \n", result1);
//     printf("result = %d \n", result2);
//     printf("result = %d \n", result3);
//     printf("result = %d \n", result4);
// }


// // Example 7-2)
// #include <stdio.h>

// int main()
// {
//     int n1 = 1;         // 0b00000000 00000000 00000000 00000001
//     int s1 = n1 << 1;   // 0b00000000 00000000 00000000 00000010
//     int s2 = n1 << 2;   // 0b00000000 00000000 00000000 00000100
//     int s3 = n1 << 3;   // 0b00000000 00000000 00000000 00001000
//     int s4 = n1 << 4;   // 0b00000000 00000000 00000000 00010000

//     printf("n1 = %d \n", n1);
//     printf("s1 = %d \n", s1);
//     printf("s2 = %d \n", s2);
//     printf("s3 = %d \n", s3);
//     printf("s4 = %d \n", s4);
// }

// // ************** 5월 22일 수요일 강의 끝 *************///////////

// // ***************5월 23일 목요일 강의 1-1시작 *************

// // Example 1-1)
// #include <stdio.h>

// int main()
// {
//     char a; // -128 ~ 127

//     a = -128;
//     printf("%d \n", a);

//     a = -129;
//     printf("%d \n", a);
//     // 언더플로우
// }


// // Example 1-2)
// #include <stdio.h>

// int main()
// {
//     unsigned char a;    // 0 ~ 255

//     a = 255;
//     printf("%d \n", a);

//     a = 256;
//     printf("%d \n", a);
//     // 오버플로우
// }


// // Example 1-3)
// #include <stdio.h>

// int main()
// {
//     unsigned char a;

//     a = 255;
//     printf("%d \n", a);

//     a += 1;
//     // a = a + 1 와 같은 식
//     printf("%d \n", a);
// }


// // Example 2-1)
// // 비트 마스크 - 특정 비트를 조작
// #include <stdio.h>

// int main()
// {
//     unsigned short data = 0x5678;   // 0101 0110 0111 1000
//                                     // 정수형이고 2byte (16bit)
//     unsigned short msk1 = 0xf000;   // 1111 0000 0000 0000
//     unsigned short msk2 = 0x0f00;   // 0000 1111 0000 0000
//     unsigned short msk3 = 0x00f0;   // 0000 0000 1111 0000
//     unsigned short msk4 = 0x000f;   // 0000 0000 0000 1111

//     printf(" 결과값 1 = %#.4x \n", data & msk1);    // 0x5000
//     printf(" 결과값 2 = %#.4x \n", data & msk2);    // 0x0600
//     printf(" 결과값 3 = %#.4x \n", data & msk3);    // 0x0070
//     printf(" 결과값 4 = %#.4x \n", data & msk4);    // 0x0008
    
//     // %x: 16진수 소문자로 출력
//     // %.4x: 최소 4자리로 출력하고 부족하면 앞에 0을 채움
//     // (ex : 8 -> 0008)
//     // %#x: 16진수 값 앞에 0x 접두사를 붙여 출력
//     // (ex : 8 -> 0x8)
//     // 따라서 data & msk의 16진수 결과를 
//     // 0x 접두사를 붙여 4자리로 출력하라는 의미 (0x0008)

//     // & 는 내가 원하는 위치에 값을 뽑아옴
// }


// // Exampe 2-2)
// #include <stdio.h>

// int main()
// {
//     unsigned short data = 0x0000;   // 0000 0000 0000 0000
//                                     // 정수형이고 2byte (16bit)
//     unsigned short msk1 = 0xf000;   // 1111 0000 0000 0000
//     unsigned short msk2 = 0x0f00;   // 0000 1111 0000 0000
//     unsigned short msk3 = 0x00f0;   // 0000 0000 1111 0000
//     unsigned short msk4 = 0x000f;   // 0000 0000 0000 1111

//     printf(" 결과값 1 = %#.4x \n", data | msk1);    // 0xf000
//     printf(" 결과값 2 = %#.4x \n", data | msk2);    // 0x0f00
//     printf(" 결과값 3 = %#.4x \n", data | msk3);    // 0x00f0
//     printf(" 결과값 4 = %#.4x \n", data | msk4);    // 0x000f
    
//     // %x: 16진수 소문자로 출력
//     // %.4x: 최소 4자리로 출력하고 부족하면 앞에 0을 채움
//     // (ex : 8 -> 0008)
//     // %#x: 16진수 값 앞에 0x 접두사를 붙여 출력
//     // (ex : 8 -> 0x8)
//     // 따라서 data | msk의 16진수 결과를 
//     // 0x 접두사를 붙여 4자리로 출력하라는 의미 (0x0008)

//     // | 는 내가 원하는 위치에 값을 바꿀수 있다
// }

// & 연산자는 특정비트를 0으로 만들고
// | 연산자는 특정비트를 1로 만든다
// ~ 연산자는 특정비트를 반전 시킨다
/*
0b10101 -> 0b11101로 만들고 싶음
  10101
|     1 << 3 -> 01000

  10101
| 01000
---------
  11101 -> 3번째 자리에 1을 추가함

*** 삭제

  11101 -> 3번째 자리의 1을 삭제하고 싶음 -> & 사용

  1 << 3 -> 01000 -> ~(1 << 3) -> 10111

  11101
 &10111
---------
  10101

*/


// // Example 3-1)
// #include <stdio.h>

// int main()
// {
//     int a, b, c;    // int타입의 a, b, c 변수 선언
//     // int a;
//     // int b;
//     // int c;       // 위와 같은 것

//     double average; // 실수타입의 average 라는 변수 선언

//     printf("정수 3개를 입력하시오 : \n");
//     scanf("%d %d %d", &a, &b, &c);  // 정수 3개를 입력받음

//     average = (double)(a + b + c) / 3;  // 평균을 구함
//     printf("평균은 : %f \n", average);   // 평균을 출력함. f는 실수형 d는 정수형
//     // 형 변환
//     // (a + b + c)의 결과는 정수형. 만약 이 합계를 정수 3으로 바로 나누면
//     // 정수 나눗셈이 되어 소수점 이하가 버려지게 됨 (ex : 245 / 3 = 81)
//     // (double)(a + b + c)는 괄호 안의 정수 합계를 
//     // 일시적으로 double 타입으로 **명시적 형 변환**함
//     // 이렇게 되면 double 타입의 값과 int 타입의 3이 연산될 때
//     // 자동으로 3도 double로 **암시적 형 변환**되어 `double` 나눗셈이 수행됨
//     // 따라서 평균이 소수점까지 정확하게 계산된다(ex : 245.0 / 3.0 = 81.666...)
// }


// // Example 3-2)
// // 명시적 형 변환 (Explicit Type Casting)
// // 프로그래머가 직접 코드를 작성해서 특정 변수나 식의 데이터 타입을 다른 타입으로 강제로 바꿔주는 것
// // 마치 요리할 때 "이 재료를 꼭 이 형태로 잘라줘!"라고 명확하게 지시하는 것과 같다

// // How use?
// // 값을 변환하고 싶은 데이터 타입을 괄호 () 안에 넣고 변환할 변수나 식 앞에 붙여준다.
// // ex : (변환의 목표가 되는 자료형) 변수_또는_식
// #include <stdio.h>

// int main() 
// {
//     int sum = 245;
//     int count = 3;

//     // 명시적 형 변환 없으면 정수 나눗셈 (소수점 이하 버림)
//     double avg1 = sum / count;
//     printf("정수 나눗셈 평균: %.2f\n", avg1); // 출력: 81.00

//     // 명시적 형 변환 (double)을 사용하여 정확한 실수 나눗셈 유도
//     double avg2 = (double)sum / count; // sum을 double로 변환해서 연산
//     printf("명시적 형 변환 평균: %.2f\n", avg2); // 출력: 81.67

//     // 정수를 실수로 변환
//     int int_val = 10;
//     float float_val = (float)int_val;
//     printf("int를 float로: %.1f\n", float_val); // 출력: 10.0

//     // 실수를 정수로 변환 (소수점 이하 버림)
//     double double_val = 123.789;
//     int casted_int = (int)double_val;
//     printf("double을 int로: %d\n", casted_int); // 출력: 123
//                                              // 이 경우 데이터 손실(정밀도 손실)이 발생
// }


// // Example 3-3)
// // 암시적 형 변환 (Implicit Type Conversion)
// // 프로그래머가 별도로 지시하지 않아도 컴파일러가 자동으로 수행하는 형 변환
// // 마치 요리사가 알아서 "이 재료는 이렇게 써야 더 맛있지!"라며 재료 형태를 바꾸는 것과 비슷
// //  주로 데이터 손실을 최소화하는 방향으로 이루진다

// // when?
// // 서로 다른 자료형 간의 연산 : 
// // int와 double처럼 다른 타입의 변수끼리 연산할 때 
// // 더 넓은 범위를 표현할 수 있는 쪽으로 작은 타입이 자동으로 변환
// // 할당(대입) 연산: 더 작은 타입의 변수에 더 큰 타입의 값을 할당할 때 
// //               (이 경우 데이터 손실이 일어날 수 있으니 주의)
// // 함수 호출 시 인자 전달: 함수의 매개변수 타입과 전달하는 인자 타입이 다를 때
// #include <stdio.h>

// int main() 
// {
//     int i = 10;
//     double d = 3.5;

//     // int와 double의 덧셈 연산:
//     // i (int)가 d (double)에 맞춰 double로 자동 변환된 후 덧셈이 이루어진다
//     double result1 = i + d; // 10 (int) -> 10.0 (double)
//     printf("int + double 결과 (double에 저장): %.1f\n", result1); // 출력: 13.5

//     // int와 double의 덧셈 연산 후 int 변수에 저장:
//     // i (int)가 double로 변환되어 덧셈 후, 다시 int로 변환되어 result2에 저장
//     // 이 과정에서 소수점 이하(.5)가 버려지면서 데이터 손실이 발생
//     int result2 = i + d;
//     printf("int + double 결과 (int에 저장): %d\n", result2); // 출력: 13 (데이터 손실 발생!)

//     // float와 double의 곱셈 연산:
//     float f = 2.0f;
//     double result3 = f * d; // f (float)가 d (double)에 맞춰 double로 자동 변환된 후 곱셈
//     printf("float * double 결과: %.1f\n", result3); // 출력: 7.0

// }

// // 암시적 형 변환의 규칙 (일반적인 승격 순서)

// // bool -> char -> short int -> int -> long int -> long long int
// // -> float -> double -> long double


// // ************ 5월 23일 금요일 강의 2 시작 ***************


// // Example 4-1)
// #include <stdio.h>

// int main()
// {
//     int num = 0;

//     printf("숫자를 입력하세요. \n");
//     scanf("%d", &num);          // 정수를 받아서 num이라는 변수에 저장

//     if (num < 5)
//     {
//         printf("입력한 숫자는 5보다 작다.\n");
//     }
//     if (num == 5)
//     {
//         printf("입력한 숫자는 5와 같다.\n");
//     }
//     if (num > 5)
//     {
//         printf("입력한 숫자는 5보다 크다.\n");
//     }
    
// }
// // if문의 특징 : if문의 조건이 참이면 실행.
// // 각각의 if문은 조건을 독립적으로 검사하여 실행함
// // 하나만 참이어야하고 나머지는 참인지 따져보지 않아도 되는 
// // if - else if - else 문과는 차이가있다.(else if와 else 블록은 검사조차 안함)

// // Example 4-2)
// #include <stdio.h>

// int main()
// {
//     int num = 0;

//     printf("숫자를 입력하세요. \n");
//     scanf("%d", &num);

//     if (num < 5)
//     {
//         printf("입력한 숫자는 5보다 작다.\n");
//     }
//     else
//     {
//         if (num == 5)
//         {
//             printf("입력한 숫자는 5와 같다./n");
//         }
//         else
//         {
//             printf("입력한 숫자는 5보다 크다.\n");
//         }
//     }
    
// }



// // Example 4-3)
// #include <stdio.h>

// int main()
// {
//     int num = 0;

//     printf("숫자를 입력하세요. \n");
//     scanf("%d", &num);

//     if (num < 5)
//     {
//         printf("입력한 숫자는 5보다 작다.\n");
//     }
//     else if(num == 5)
//     {
//         printf("입력한 숫자는 5와 같다.\n");
//     }
//     else
//     {
//         printf("입력한 숫자는 5보다 크다.\n");
//     }
    
// }

// // 5월 23일 2강 27분 35초

// // Example 5-1)
// // switch case문
// /*
// // switch case문의 기본 형태
// // switch (표현식)  // 값이 정수가 되어야함
// // {
// // case 정수값1:
//       문장1;
//       break;

//       // case 정수값2:
//       문장2;
//       break;

// default:    // 어떤 case에도 해당되지 않을 때
//       break;
// }
// // break를 만나면 자기가 속한 중블럭을 나간다
// // 나중에 반복문에서 활용됨 -> 조건을 만족하면 튕겨져 나감
// */
// #include <stdio.h>
                   

// int main()
// {
//     int num;       // 사용자의 입력을 저장할 정수형 변수 'num'을 선언합니다.

//     printf("미세먼지 농도를 선택하시오\n");
//     printf("1. 좋음\n");                  
//     printf("2. 보통\n");                  
//     printf("3. 나쁨\n");                  
    
//     scanf("%d", &num);      // 입력한 정수를 num 변수의 메모리 주소(&num)에 저장
//                             // %d는 10진수 정수를 입력받기 위한 형식 지정자

//     switch (num)            // num 변수에 저장된 값에 따라 분기(갈라져 실행)하는 switch문을 시작
//     {
//     case 1:                 // 만약 num 의 값이 1과 같다면, 이 case 아래의 코드를 실행
//         printf("미세먼지 농도가 좋으니까 마스크 안써도됨\n"); // 해당 메시지를 출력합
//         break;              // switch 문을 즉시 빠져나감. 'break'가 없으면 다음 'case'도 계속 실행된다

//     case 2:                    
//         printf("미세먼지 농도가 보통이니까 마스크 대충 쓰세요\n"); 
//         break;                 

//     case 3:                    
//         printf("미세먼지 농도가 나쁘니까 방독면 착용하세요\n"); 
//         break;                
    
//     default:                // num 의 값이 위에 나열된 어떤 case(1, 2, 3)와도 일치하지 않을 때 실행
//         printf("잘못눌렀습니다\n"); // 에러 메시지를 출력
//         break;                 
//     }
    
//     return 0;                  
// }


// // Example 5-2)
// // break가 없는 경우 (fall-through)
// #include <stdio.h>

// int main()
// {
//     int num;       // 사용자의 입력을 저장할 정수형 변수 'num'을 선언합니다.

//     printf("미세먼지 농도를 선택하시오\n");
//     printf("1. 좋음\n");                  
//     printf("2. 보통\n");                  
//     printf("3. 나쁨\n");                  
    
//     scanf("%d", &num);

//     switch (num)
//     {
//     case 1:
//         printf("1번 메시지\n");
//         break;

//     case 2:
//         printf("2번 메시지\n"); // num이 2이므로 여기로 점프하여 실행
//         // break;  <- 이 부분이 없다고 가정
    
//     case 3:
//         printf("3번 메시지\n"); // 2번이 끝난 후 자동으로 이어서 실행
//         break;
//     }
// }


// // Example 5-3)
// // 여러 case가 동일한 코드를 공유할 때 의도적으로 사용하기도 함
// #include <stdio.h>

// int main()
// {
//     int num;       // 사용자의 입력을 저장할 정수형 변수 'num'을 선언합니다.

//     printf("미세먼지 농도를 선택하시오\n");
//     printf("1. 좋음\n");                  
//     printf("2. 보통\n");                  
//     printf("3. 나쁨\n");                  
    
//     scanf("%d", &num);

//     switch (num)
//     {
//     case 1:  // 좋음
//     case 2:  // 보통
//     // case 1과 case 2 모두 이 코드를 공유함
//     printf("공기 질이 양호한 편입니다. 환기하세요.\n"); 
//     break; // 공통 코드가 끝나면 switch 문을 나감

//     case 3:  // 나쁨
//     printf("공기 질이 나쁩니다. 창문을 닫으세요.\n");
//     break;
    
//     default:
//     printf("잘못된 입력입니다.\n");
//     break;
//     }
// }


// // Example 6)
// #include <stdio.h>
// // while 문 (조건반복문 - 조건이 참이 될때까지)
// int main()
// {
//     int weight = 80;  // weight를 선언하고 초기화
//     int count = 0;    // 운동한 날짜를 세기 변수 count를 0으로 초기화

//     while (weight > 60) // 'while' 반복문 시작. 괄호 안의 조건식(weight > 60)이 참인 동안 반복
//     // while(1) 무한루프 1은 C 언어에서 참(true)을 
//     // 의미 하므로 while(1)은 항상 참인 조건이 되어 
//     // 프로그램이 끝없이 반복된다 
//     {
//         printf("매일 빡시게 운동해서 1kg 감량하기\n"); // 조건이 참일 때마다 이 메시지를 출력
//         weight--;   // weight 변수의 값을 1씩 감소시킴(80 -> 79 -> 78 ...)
//         count++;    // count 변수의 값을 1씩 증가시킴(0 -> 1 -> 2 ...)
//     } // 조건이 거짓(weight <= 60)이 되면 이 중괄호 블록을 빠져나감
    
//     printf("축하합니다. 운동 안해도 됨\n"); 
//     // 반복문이 끝난 후 이 메시지를 출력
   
//     printf("%d 일 운동 했음 \n\n", count); 
//     // 최종적으로 운동한 날짜(count)를 출력

//     return 0;
// }


// // Example 7-1)
// #include <stdio.h> 
// // for 문 (반복문) // for(;;) 무한반복문
// int main()
// {
//     int weight; 
//     int count = 0;

//     // for(초기식(값); 조건식(비교); 증감식(변화))
//     for(weight = 80; weight > 70; weight--)
//     // [1] 초기식: weight = 80 -> 반복문이 시작될 때 단 한 번만 실행됨
//     // [2] 조건식: weight > 70 -> 반복을 계속할지 검사합니다. 참이면 반복, 거짓이면 종료
//     // [3] 증감식: weight-- -> 반복문 블록이 한 번 실행될 때마다 실행
//     // weight = 80 부터 시작해서 70보다 클때까지 반복
//     {
//         printf("빡시게 운동 했음\n"); // 조건이 참일 때마다 이 메시지를 출력
//         count++; // 반복 횟수를 1씩 증가시킨다
//     } // 조건이 거짓(weight <= 70)이 되면 이 중괄호 블록을 빠져나간다.

//     printf("축하합니다. 운동 안해도됨\n %d일 운동했음\n", count); // 반복문이 끝난 후 최종 결과를 출력

//     return 0;
// }


// // Example 7-2)
// // 중첩 for문
// #include <stdio.h>

// int main() {
//     int i, j; 

//     // [1] 바깥쪽 for 문 시작 (i = 0, 1, 2)
//     for(i = 0; i < 3; i++) // i가 0부터 2까지, 총 3번 반복
//     {
//         printf("외부 for문 시작 %d\n", i); // 바깥쪽 반복이 시작될 때마다 출력
        
//         // [2] 안쪽 for 문 시작 (i의 각 반복마다 j = 0, 1, 2)
//         for(j = 0; j < 3; j++) // i의 값이 바뀔 때마다, j는 0부터 2까지 다시 3번 반복
//         {
//             printf("내부 for문 시작 %d\n", j); // 안쪽 반복이 시작될 때마다 출력
//         }
        
//         printf("내부 for문 끝 %d\n\n", i); // 안쪽 반복문이 완전히 끝난 후 출력
//     }
    
//     return 0;
// }


// // Example 7-3-1)
// // i증가 j증가
// #include <stdio.h> 

// int main()
// {
//     int i, j;

//     // [1] 바깥쪽 for 문: 줄(행)의 반복을 제어
//     for(i = 0; i < 5; i++) // i는 0부터 4까지 총 5번 반복하며 각 반복이 한 줄을 만든다
//     {
//         // [2] 안쪽 for 문: 각 줄에서 별의 개수(열)를 제어
//         for(j = 0; j <= i; j++) // j는 0부터 i의 값까지 반복
//         {
//             printf("*"); // 줄바꿈 없이 별을 출력
//         }
//         printf("\n"); // 안쪽 for 문이 끝나면 줄바꿈을 하여 다음 줄로 넘어간다
//     }
    
//     return 0;
// }


// // Example 7-3-2p) practice
// // 결과적으로 맞는 코드지만 j가 감소해야되는데 j=i에서 i가 0에서 시작함으로써
// // 코드가 직관적이지가 않다.
// // i증가 j 감소
// #include <stdio.h>

// int main()
// {
//   int i, j;

//   for (i = 0; i < 5; i++)
//   {
//     for (j = i; j >= 0; j--)
//     {
//       printf("*");
//     }
//     printf("\n");
//   }
//   return 0;
// }


// // Example 7-3-2)
// // i증가 j감소
// #include <stdio.h>

// int main()
// {
//     int i, j;

//     // [1] 바깥 for문: i는 0부터 4까지 5번 반복하며, 줄(행)을 만듭니다.
//     for (i = 0; i < 5; i++)
//     {
//         // [2] 안쪽 for문: j는 4부터 '4-i'까지 반복하며 별의 개수를 제어합니다.
//         for (j = 4; j >= 4 - i; j--) // i가 0이면 j가 1번, i가 1이면 j가 2번 반복합니다.
//         {
//             printf("*");
//         }
//         printf("\n");
//     }
//     return 0;
// }


// // Example 7-3-3p) practice
// // i감소 j증가
// // j는 증가하는데 j=i에서 i가 5부터 시작해서 점차 1까지 가는 숫자라서
// // 직관적이지가 않는 코드이다.
// #include <stdio.h>

// int main()
// {
//   int i, j;

//   for (i = 5; i > 0; i--)
//   {
//     for (j = i; j <= 5; j++)
//     {
//       printf("*");
//     }
//     printf("\n");
//   }
//   return 0;
// }


// // Example 7-3-3)
// //i 감소 j 증가
// #include <stdio.h>

// int main()
// {
//     int i, j;

//     // [1] 바깥 for문: i는 5부터 1까지 감소하며 5줄을 생성
//     for (i = 5; i > 0; i--) 
//     {
//         // [2] 안쪽 for문: j는 0부터 (5 - i)까지 증가하며 별의 개수를 제어
//         for (j = 0; j <= (5 - i); j++)
//         {
//             printf("*");
//         }
//         printf("\n");
//     }
//     return 0;
// }


// // Example 7-3-4)
// // i감소 j감소
// #include <stdio.h>

// int main()
// {
//   int i, j;

//   for (i = 5; i > 0; i--)
//   {
//     for (j = 5; j >= i; j--)
//     {
//       printf("*");
//     }
//     printf("\n");
//   }
//   return 0;
// }



// // Example 7-4-1)
// // i는 4부터 1까지 감소시키고 j는 0부터 i-1까지 증가
// #include <stdio.h>

// int main()
// {
//     int i, j;

//     // [1] 바깥 for문: i는 4, 3, 2, 1로 감소하며 총 4번 반복
//     for (i = 4; i > 0; i--) // i가 4, 3, 2, 1 순서로 변하며 4줄을 만듦
//     {
//         // [2] 안쪽 for문: j는 0부터 i보다 작을 때까지 증가
//         for (j = 0; j < i; j++) // i의 값에 따라 j의 반복 횟수가 4, 3, 2, 1로 줄어듦
//         {
//             printf("*");
//         }
//         printf("\n");
//     }
//     return 0;
// }


// // Example 7-4-2)
// // i는 0부터 3까지 증가 시키고 j는 4부터 i+1 감소
// #include <stdio.h>

// int main()
// {
//   int i, j;

//   // [1] 바깥 for문: i는 0, 1, 2, 3으로 증가하며 총 4번 반복
//   for (i = 0; i < 4; i++) // i가 0, 1, 2, 3 순서로 변하며 4줄을 만듦
//   {
//     // [2] 안쪽 for문: j는 4부터 i보다 클 때까지 감소
//     for (j = 4; j > i; j--)
//     {
//       printf("*");
//     }
//     printf("\n");
//   }
//   return 0;
// }


// // Example 7-4-3)
// // i 감소시키고 j 또한 i에 값부터 감소하여 별의 갯수 줄어듦
// #include <stdio.h>

// int main()
// {
//     int i, j;

//     // 바깥쪽 for문: i는 4부터 1까지 감소
//     for (i = 4; i > 0; i--)
//     {
//         // 안쪽 for문: j는 i부터 1까지 감소
//         for (j = i; j > 0; j--) 
//         // i가 줄어들면 j의 시작점도 함께 줄어들어 별의 개수가 감소
//         {
//             printf("*");
//         }
//         printf("\n");
//     }
//     return 0;
// }


// // Example 7-4-4)
// // i 증가 j도 증가. 안쪽 for문의 조건식을 역방향으로 설정해서 별의 개수를 줄임
// // 역방향 설정 : 큰수에서 작은수로 줄어듦. 근데 이 예제에서는 
// // j < (4 - i)로 인해서 j가 도달해야할 숫자가 계속 줄어 들어서 작은수로 줄어드는것
// #include <stdio.h>

// int main()
// {
//     int i, j;

//     // 바깥쪽 for문: i는 0부터 3까지 증가
//     for (i = 0; i < 4; i++)
//     {
//         // 안쪽 for문: j는 0부터 (4 - i)보다 작을 때까지 증가
//         for (j = 0; j < (4 - i); j++)
//         // (4 - i)는 i가 증가할수록 줄어들어 별의 개수를 감소시킴(역방향 설정)
//         // for (j = i; j < 4; j++)
//         {
//             printf("*");
//         }
//         printf("\n");
//     }
//     return 0;
// }


// // Example 7-5)
// // 별찍기
// #include <stdio.h>

// int main()
// {
//   int i, j;

//   for (i = 0; i < 5; i++)
//   {
//     for (j = 0; j <= i; j++)
//     {
//       printf("*");
//     }
//     printf("\n");
//   }
//   for (i = 4; i > 0; i--)
//   {
//     for (j = 0; j < i; j++)
//     {
//       printf("*");
//     }
//     printf("\n");
//   }
  
//   return 0;
// }


// // Example 7-6-1)
// // while문으로 응용1
// #include <stdio.h>

// int main()
// {
//     int i = 0; // i는 0부터 시작

//     // 바깥 while문: i가 5보다 작을 때까지 반복 (0, 1, 2, 3, 4)
//     while (i < 5) 
//     {
//         int j = 0; // 안쪽 while문이 시작될 때마다 j는 0으로 초기화
        
//         // 안쪽 while문: j가 i보다 작거나 같을 때까지 반복
//         while (j <= i) 
//         {
//             printf("*");
//             j++; // j의 값을 1씩 증가
//         }
        
//         printf("\n"); // 한 줄의 별 출력이 끝나면 줄바꿈
//         i++; // 바깥 while문의 반복이 끝나면 i의 값을 1씩 증가
//     }
    
//     return 0;
// }


// // Example 7-6-2)
// // while문으로 응용2
// #include <stdio.h>

// int main()
// {
//     int i = 4; // for 문의 초기식과 동일

//     while (i > 0) // for 문의 조건식과 동일
//     {
//         int j = 0; // 안쪽 for 문의 초기식과 동일
//         while (j < i) // 안쪽 for 문의 조건식과 동일
//         {
//             printf("*");
//             j++; // 안쪽 for 문의 증감식과 동일
//         }
//         printf("\n");
//         i--; // 바깥쪽 for 문의 증감식과 동일
//     }
//     return 0;
// }


// // Example 7-6-3) practice
// // while문으로 별찍기
// #include <stdio.h>

// int main()
// {
//   int i = 0;

//   while (i < 5)
//   {
//     int j = 0;
//     while (j <= i)
//     {
//       printf("*");
//       j++;
//     }
//     printf("\n");
//     i++;
//   }
//   while (i < 4)
//   {
//     int j = 4;
//     while (j > i)
//     {
//       printf("*");
//       j--;
//     }
//     printf("\n");
//     i++;
//   }
  
//   return 0;
// }


// // Example 7-6-3)
// // while문으로 별찍기
// #include <stdio.h>

// int main()
// {
//   int i = 0;

//   // 첫 번째 while문: 정삼각형
//   while (i < 5)
//   {
//     int j = 0;
//     while (j <= i)
//     {
//       printf("*");
//       j++;
//     }
//     printf("\n");
//     i++;
//   }
  
//   // 두 번째 while문: 역삼각형
//   // 수정사항 : i는 5부터 시작하지만 4줄의 역삼각형을 위해 i의 초기값을 4로 설정
//   i = 4; // ⭐ i의 값을 4로 재설정
//   while (i > 0) // ⭐ i가 0보다 클 때까지 반복
//   {
//     int j = 0;
//     while (j < i)
//     {
//       printf("*"); // i = 4일때 j = 0, 0 < 4 -> 0,1,2,3 4번반복
//       j++;
//     }
//     printf("\n");
//     i--; // ⭐ i의 값을 감소시켜 별의 개수를 줄임
//   }
  
//   return 0;
// }


/*
* 함수 (Function)
- 프로그래밍에서 함수란 특별한 목적의 작업을 수행하기 위한 독립적으로 설계된
  프로그램 코드의 집합 !!
- 표준함수, 사용자 정의 함수

* 함수의 정의와 목적
  특정 작업을 수행하도록 설계된 독립적인 코드 블록이다. 
  함수를 사용하는 주된 목적은 다음과 같다.

- 코드 재사용성 : 동일한 작업을 반복해서 수행해야 할 때 
               매번 코드를 새로 작성할 필요 없이 함수를 
               한 번 만들어두면 여러 곳에서 호출하여 사용할 수 있다.

- 코드 구조화 : 복잡한 프로그램을 여러 개의 작은 함수로 나누면
              각 함수가 하나의 특정 기능만 담당하게 되어 
              코드를 이해하고 관리하기 쉬워진다.

- 유지보수성 : 프로그램에 문제가 발생했을 때 
            문제가 발생한 함수만 수정하면 되기 때문에 
            전체 프로그램을 쉽게 유지보수할 수 있다.


* 함수의 기본 구조
함수는 크게 세 가지 요소로 구성된다

================================================
반환_타입 함수_이름(매개변수_목록)
{
  // 함수가 수행할 작업 코드
  return 반환_값; // 반환_타입이 void가 아닐 경우 필수
}
================================================

반환_타입(Return Type) : 함수가 작업을 마친 후 호출한 곳으로 돌려줄 값의 데이터 타입
                       만약 돌려줄 값이 없다면 void를 사용

함수_이름(Function Name) : 함수를 호출할 때 사용하는 이름
                          변수 이름 규칙과 동일하게 작성

매개변수_목록(Parameter List) : 함수가 작업을 수행하는 데 필요한 입력 값
                            괄호 () 안에 데이터 타입과 변수 이름을 콤마(,)로 구분하여 나열합 
                            입력 값이 없다면 비워 둠

return: 함수가 실행을 마치고 반환할 값을 지정하는 키워드 
        반환_타입이 void가 아닐 경우 반드시 포함되어야 함.
        하지만 compiler가 똑똑해져서 안쓰는 경우도 있긴함.


type function_name(parameter list, , , ,)
// type : 함수가 어떤 타입인지, function_name : 변수명처럼 함수이름
{
  decrlarations // 선언
  statement     // 실행되어야할 코드
} // prototype

int sum(x, y)
{
  int sum;  // 선언

  sum = x + y; // 함수의 본체

  return sum; // sum 값을 반환
}
// 이 함수는 x와 y라는 두 개의 정수 값을 입력받아 그 합을 계산한 후
// 그 결과(sum)를 정수형으로 반환한다. 
// 함수를 호출한 쪽에서는 이 return 값을 변수에 저장하거나 다른 연산에 사용할 수 있다.



void sum(x, y)
{
  int sum;
  
  sum = x + y;

  //void는 return 값이 필요없음 
}
// 이 함수는 x와 y의 합을 계산하지만 그 결과를 반환하지 않는다. 
// 즉, 함수 내부에서만 sum 변수가 존재하고 함수가 끝나는 동시에 사라진다
// 이런 함수는 주로 화면에 메시지를 출력하거나 
// 특정 상태를 변경하는 등 반환할 필요가 없는 작업을 수행할 때 사용된다.

*/

// Example Function)
// #include <stdio.h>

// // 함수 선언 (Function Declaration)
// // 컴파일러에게 'int형을 반환하고 int형 매개변수 2개를 받는 sum 함수가 있다'고 미리 알려줍니다.
// int sum(int x, int y);

// int main()
// {
//     int a = 10, b = 20;
//     int result;

//     // 함수 호출 (Function Call)
//     // 미리 선언된 sum 함수를 실제 실행시킵니다.
//     // a와 b의 값이 sum 함수의 x와 y로 전달됩니다.
//     result = sum(a, b); 

//     printf("두 수의 합은 %d입니다.\n", result);

//     return 0;
// }

// // 함수 정의 (Function Definition)
// // 함수가 실제 어떤 작업을 할지 코드로 구현합니다.
// int sum(int x, int y)
// {
//     return x + y;
// }