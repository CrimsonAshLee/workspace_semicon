/*
 * ultrasonic.c
 *
 *  Created on: Jul 6, 2025
 *      Author: user8
 */

#include "ultrasonic.h"

//uint16_t IC_Value1 = 0;
//uint16_t IC_Value2 = 0;
//uint16_t echoTime = 0;
//uint8_t captureFlag = 0;
//uint8_t distance = 0;

// 각 센서의 거리 측정용 변수
uint16_t ic_start = 0, ic_end = 0;
uint8_t is_capturing = 0;

uint8_t distance_center = 0;
uint8_t distance_left = 0;
uint8_t distance_right = 0;

//// 각각 거리 전역 변수
//uint8_t distance_center = 0;
//uint8_t distance_left = 0;
//uint8_t distance_right = 0;


//// 공통 캡처값
//uint16_t IC1 = 0, IC2 = 0;
//uint8_t captureFlag_center = 0;
//uint8_t captureFlag_left = 0;
//uint8_t captureFlag_right = 0;

//void HCSR04_TRIG(void)
//{
//  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
//  delay_us(10);
//  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
//
//  __HAL_TIM_ENABLE_IT(&htim2, TIM_IT_CC1);  // ECHO 인터럽트 활성화 (변경)
//}

// TRIG 함수
void Trigger_Center(void)
{
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
  delay_us(2);
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
  delay_us(10);
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
}

void Trigger_Left(void)
{
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_RESET);
  delay_us(2);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_SET);
  delay_us(10);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_RESET);
}

void Trigger_Right(void)
{
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);
  delay_us(2);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);
  delay_us(10);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);
}

void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
  uint32_t diff;

  if (htim->Instance == TIM2 && htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
  {
    if (is_capturing == 0)
    {
      ic_start = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
      is_capturing = 1;
      __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_FALLING);
    }
    else
    {
      ic_end = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
      diff = (ic_end >= ic_start) ? (ic_end - ic_start) : (0xFFFF - ic_start + ic_end);
      distance_center = diff / 58;
      is_capturing = 0;
      __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING);
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
    }
  }

  if (htim->Instance == TIM4)
  {
    if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
    {
      static uint8_t flag_L = 0;
      static uint32_t t1_L, t2_L;

      if (!flag_L)
      {
        t1_L = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
        flag_L = 1;
        __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_FALLING);
      }
      else
      {
        t2_L = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
        diff = (t2_L >= t1_L) ? (t2_L - t1_L) : (0xFFFF - t1_L + t2_L);
        distance_left = diff / 58;
        flag_L = 0;
        __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING);
        __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
      }
    }

    if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2)
    {
      static uint8_t flag_R = 0;
      static uint32_t t1_R, t2_R;

      if (!flag_R)
      {
        t1_R = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);
        flag_R = 1;
        __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_2, TIM_INPUTCHANNELPOLARITY_FALLING);
      }
      else
      {
        t2_R = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);
        diff = (t2_R >= t1_R) ? (t2_R - t1_R) : (0xFFFF - t1_R + t2_R);
        distance_right = diff / 58;
        flag_R = 0;
        __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_2, TIM_INPUTCHANNELPOLARITY_RISING);
        __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
      }
    }
  }
}

//void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
//{
//  if (htim->Instance == TIM2 && htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)  // TIM2로 변경
//  {
//    if (captureFlag == 0)
//    {
//      IC_Value1 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
//      captureFlag = 1;
//      __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_FALLING);
//    }
//    else if (captureFlag == 1)
//    {
//      IC_Value2 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
//      __HAL_TIM_SET_COUNTER(htim, 0);
//
//      if (IC_Value2 > IC_Value1)
//        echoTime = IC_Value2 - IC_Value1;
//      else
//        echoTime = (0xFFFF - IC_Value1 + IC_Value2);
//
//      distance = echoTime / 58;
//      captureFlag = 0;
//
//      __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING);
//      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
//    }
//  }
//}
